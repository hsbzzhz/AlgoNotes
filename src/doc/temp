
redis数据类型 https://blog.csdn.net/qq_45076180/article/details/109458668

tcc[https://blog.csdn.net/sinat_32873711/article/details/129848895]

xa[https://juejin.cn/post/7116916308825866254]

可靠消息最终一致性方案[https://blog.csdn.net/Pastxu/article/details/115731491?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-115731491-blog-130501345.235^v43^pc_blog_bottom_relevance_base4&spm=1001.2101.3001.4242.2&utm_relevant_index=4]

RocketMQ半消息（2PC）
[https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&mid=2650860292&idx=3&sn=21be1aef473c4ceb1f2b00116fd4f671&chksm=bd017e4a8a76f75c89aea1b820f6e76071406c9e3cdd7c61cad99c92d6a59baff1daaf751d38&scene=27]
[https://blog.csdn.net/weixin_44606481/article/details/129903032]
1. A系统在执行本地事务前发送一个prepared消息到mq（prepared的topic是不可见的），如果这个prepared消息发送失败久取消后续操作
2. 如果这个消息发送成功，就继续执行本地事务，如果成功通知mq发送确认信息，如果失败就本地回滚并通知mq删除prepared消息
3. A系统发送了确认消息后，B系统会通过Topic收到确认消息，然后开始执行本地事务
4. 期间mq会定时论文所有prepared消息回调服务接口，查询本地事务处理结果。此步骤目的是避免本地事务执行成功，但确认消息缺发送失败
   1. 需要设计一张Transaction表，和业务表绑定，方便RocketMQ回查
5. 如果B系统中本地事务执行失败，首先会尝试重试，如遇失败需要通知A系统回滚（这里具体操作）
   1. RocketMQ不能保障消息重复，所以在消费端需要做幂等处理


https://blog.csdn.net/talenter111/article/details/111867384?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-111867384-blog-117655119.235^v43^pc_blog_bottom_relevance_base4&spm=1001.2101.3001.4242.3&utm_relevant_index=5


1. innodb中的事务
start transaction ... end
读未提交
使用MVCC
读不会加任何锁，而写会加排他锁，并到事务结束之后释放。

读已提交
使用MVCC
读不会加锁，事务中每个一致读都会设置并读取自己的新快照。（每次都是新快照）
加锁读、更新语句、删除语句，mysql仅对where条件中的索引列的记录加锁，不会锁间隙。

可重复读
使用MVCC
同一个事务中所有的一致读将取该事务中第一次此类读取锁建立的快照。（取第一次读建立快照）

加锁读、更新语句、删除语句，mysql不仅会对where条件中索引列的记录加锁，还会锁定他们之间的间隙（间隙锁），如果索引是唯一索引会降级为行锁。

序列化
读会加共享锁，写会加排他锁，读写互斥，悲观锁，并发能力差

2. B+树
- b+树叶子节点间通过指针相连，形成双向链表，使得在范围查询和排序操作上有性能优势。
- 叶子节点构成一个有序链表，有利于顺序遍历和检索数据。
- b+树将所有数据记录存储在叶子节点，使得非叶子节点容量更大，这样可以减少树的高度，进一步优化磁盘I/O效率。

http://hxz.ink/2021/09/11/reactor-pattern/

原子性：一个事务必须视为不可分割的最小工作单位。从开启事务，直到提交该事务，其间不管进行了多少次数据库的增、删、改、查的操作都视为一个整体，要么都执行，要么都不执行。主要依赖undo log来实现原子性。
一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。主要是指数据处于一种语义上的有意义且正确的状态，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。主要是通过原子性、隔离性、持久性保证数据库状态的一致性。
隔离性：主要是指多个事务之间相互独立，互不干扰。事务隔离分为不同级别，包括未提交读（Read uncommitted）、已提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。主要依赖的是MVCC或者锁来实现的隔离性。
持久性：指一个事务一旦成功提交，它对数据库中的数据的改变是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。主要依赖的是redo log来保证持久性。
undo log：在进行insert，delete，update操作时产生方便回滚的日志。
不同事务或相同事务对同一记录的修改，会生成一条undo log生成的记录线性表，
链首是最新的记录， 链尾是最早的记录
Read view：是事务进行快照读时产生的视图，


@RestController 注解
@Controller

@ResponseBody
将返回值以指定格式写入http response body中

对象存储在内存中，如果想把内存传输，就需要进行序列化
因为springboot在提供接口的时候涉及到网络的传输，所以传输的对象需要实现Serializable接口，
但是@RestController 接口已经帮助转换成json对象，而json对象是已经实现了Serializable接口的，
所以不需要手动序列化


String s0 = "abc"
至多创建一个对象
会判断字符串是否在常量池中，然后将s0指向常量池的地址。（在编译阶段就会在内存中创建）
String s1 = new String("abc");
至多创建两个对象
会在堆内存中创建一个String对象，然后指向常量池中的地址，s1指向内存中的对象。（在运行时才会在堆内存中创建）
