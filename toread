二叉树有根节点，根节点值为-1。且将根节点所在的位置记为第0层，第0个。
给出一组operations操作。比如：operations[i] = [[0,0] , [0,0] , [1,1] , [1,0] , [2,1] , [2,1]]。
意为在第j层，第k个节点上构建值为i的子节点，构建原则如下：
如果该节点没有左子节点，先生成左子节点
如果该节点存在左子节点，则生成右子节点
如果该节点左右子节点均已存在，则无事发生

注意这里第j层指的是operations数组中的第一个数字，例如[1,0]中的1，[2,1]中的2。
第k个指的是operations数组中的第二个数字，例如[1,0]中的0，[2,1]中的1。并且尤其注意这里的k指的是相应层出生顺序为k的节点，而非从左到右的顺序！！！
笔者描述能力有限，如果还不懂，可以看下面的具体讲解与图形。
例如题目中提到的operations[i] = [[0,0] , [0,0] , [1,1] , [1,0] , [2,1] , [2,1]]，应该构建出如下的二叉树图形：


class Solution {
    private Map<Integer, Map<Integer, BinaryTreeNode>> map = new HashMap<>();
 
    public BinaryTreeNode createTree(int[][] operations) {
        BinaryTreeNode root = new BinaryTreeNode(-1);
        Map<Integer, BinaryTreeNode> layer0 = new HashMap<>();
        map.put(0, layer0);
        layer0.put(0, root);
        int i = 0;
        for (int[] operation : operations) {
            Map<Integer, BinaryTreeNode> layer = map.getOrDefault(operation[0], new HashMap<>());
            map.put(operation[0], layer);
            BinaryTreeNode pNode = layer.get(operation[1]);
            BinaryTreeNode cNode = new BinaryTreeNode(i);
            if (pNode.left == null) {
                pNode.left = cNode;
            } else if (pNode.right == null) {
                pNode.right = cNode;
            } else {
                i++;
                continue;
            }
            int newHeight = operation[0] + 1;
            Map<Integer, BinaryTreeNode> newLayer = map.getOrDefault(newHeight, new HashMap<>());
            map.put(newHeight, newLayer);
            newLayer.put(newLayer.size(), cNode);
            i++;
        }
        return root;
    }
}

22222222222222222222222222222222

供电装置每单位时间可以以supplyRate给外部设备供电。多余的电可以存储到存储装置。
存储装置每单位时间最多可以存储storeRate的电，当它给外部设备供电时也最多以每单位时间storeRate进行供电。存储装置可存电量的上限为storeLimit。
每个外部设备具有唯一标识符index，自己每单位时间所消耗的电量为consume，自身优先级为priority。

整个系统供电规则如下：
优先使用供电装置给外部设备供电，如果供电装置不足以给外部设备供电了，可以使用存储装置配合一起供电。
先给优先级高的设备供电，若优先级高的设备不足以被供电，则优先级低的也不会被供电。
整个系统类为myEnergySupplySystem，希望您设计类函数实现以下功能：
初始化该电力系统类，myEnergySupplySystem(int supplyRate, int storeLimit, int storeRate)。
void Add(int time, int index, int consume, int priority)：在某一时刻time添加具有(index,consume,priority)的外部设备。
int Remove(int time, int index)：在某一时刻time删除标识符为index的外部设备。若有该设备且成功删除返回1，否则返回-1。
int Query(int time)：在某一时刻查询存储装置的当前电量。

举例：
	myEnergySupplySystem system1(8, 12, 5);
	system1.Add(1, 301, 2, 200);
	system1.Add(3, 405, 8, 100);
	system1.Add(5, 102, 13, 500);
        system1.Remove(8, 102);
那么可以思考一下每个时刻Query函数返回值是啥，如果答案和下面一样，则证明你的题目理解没有问题了。
answer:【5,10,12,10,8,3,8,3,1,6,4...】(从time=1开始)
如果你的答案不一样，请先别急，慢慢看下面的分析：
0~1：此时没有外部设备，因此存储设备可从供电装置中存5
1~2: 301用2，存储存10
2~3: 301用2，存储到达上限，存12
3~4: 301用2, 405用8， 存储给405供电2，存10
4~5: 301用2, 405用8， 存储给405供电2，存8
5~6: 102用13,  存储给102供电5，存3
6~7：不足以给102供电了，讲屁话没有用，让别的机器也别供了，存储设备可从供电装置中存5，存8
7~8：102用13,  存储给102供电5，存3
8~9: 301用2, 405用8，存储给405供电2，存1
9~10: 301用2，存储设备可从供电装置中存5，存6
10~11:301用2,405用8，存储给405供电2，存4
...
一定要注意6~7时刻的规则2限定并且此时供电装置是可以给存储装置供电的，以及9~10时刻供电装置也是可以给存储装置供电的！！！

好啦，题目描述完毕，给出个人解题思路：
本题条件还是很多的，需要分情况将各种条件考虑全面，我的解题思路就是新增一个通用函数operate，来执行每个单位时间供电系统的变化。然后对于Add,Remove,Query操作中都先执行一下上一个时刻到此时刻的每一个单位时间的operate。
这个operate需要把题目中限定的条件充分考虑到，比如供电系统什么时刻自己供电就行，什么时候需要配合存储装置一起供电，什么时候可以给存储装置存点，在代码中有注释说明。下面直接上代码。
	 
	class EnergySupplySystem {
	    static class EnergySupply {
	        public EnergySupply(int unitSupply) {
	            this.unitSupply = unitSupply;
	        }
	 
	        int unitSupply;
	    }
	 
	    static class StoreSystem {
	        public StoreSystem(int storeRate, int storeLimit) {
	            this.storeRate = storeRate;
	            this.storeLimit = storeLimit;
	            this.storeNow = 0;
	        }
	 
	        public void store(int store) {
	            int canStore = Math.min(store, storeRate);
	            this.storeNow = Math.min(this.storeLimit, this.storeNow + canStore);
	        }
	 
	        int storeRate;
	 
	        int storeLimit;
	 
	        int storeNow;
	    }
	 
	    static class Machine {
	        public Machine(int index, int time, int consume, int priority) {
	            this.index = index;
	            this.addTime = time;
	            this.unitConsume = consume;
	            this.priority = priority;
	        }
	 
	        int index;
	 
	        int addTime;
	 
	        int unitConsume;
	 
	        int priority;
	    }
	 
	    EnergySupply energySupply;
	 
	    StoreSystem storeSystem;
	 
	    List<Machine> machineList;
	 
	    int preCalcTime;
	 
	    public EnergySupplySystem(int supplyRate, int storeLimit, int storeRate) {
	        energySupply = new EnergySupply(supplyRate);
	        storeSystem = new StoreSystem(storeRate, storeLimit);
	        machineList = new ArrayList<>();
	        preCalcTime = 0;
	    }
	 
	    public void add(int time, int index, int consume, int priority) {
	        useElectricity(time);
	        preCalcTime = time;
	        Machine machine = new Machine(index, time, consume, priority);
	        machineList.add(machine);
	        machineList.sort((o1, o2) -> Integer.compare(o2.priority, o1.priority));
	    }
	 
	    public int remove(int time, int index) {
	        Machine machine = getMachine(index);
	        if (machine == null) {
	            return -1;
	        }
	        useElectricity(time);
	        machineList.remove(machine);
	        preCalcTime = time;
	        return 1;
	    }
	 
	    public int query(int time) {
	        useElectricity(time);
	        preCalcTime = time;
	        return storeSystem.storeNow;
	    }
	 
	    private void useElectricity(int nowTime) {
	        while (nowTime != preCalcTime) {
	            unitConsumeAndStore();
	            nowTime--;
	        }
	    }
	 
	    private Machine getMachine(int index) {
	        for (Machine machine : machineList) {
	            if (machine.index == index) {
	                return machine;
	            }
	        }
	        return null;
	    }
	 
	    private void unitConsumeAndStore() {
	        int unitSupply = energySupply.unitSupply;
	        int storeAndCanUseNow = Math.min(storeSystem.storeNow, storeSystem.storeRate);
	        storeSystem.storeNow = storeSystem.storeNow - storeAndCanUseNow;
	        for (Machine machine : machineList) {
	            if (unitSupply + storeAndCanUseNow < machine.unitConsume) {
	                break;
	            }
	            int unitConsume = machine.unitConsume;
	            if (unitSupply >= unitConsume) {
	                unitSupply = unitSupply - unitConsume;
	                continue;
	            }
	            unitConsume = unitConsume - unitSupply;
	            unitSupply = 0;
	            if (storeAndCanUseNow >= unitConsume) {
	                storeAndCanUseNow = storeAndCanUseNow - unitConsume;
	                continue;
	            }
	            storeAndCanUseNow = 0;
	            break;
	        }
	        if (storeAndCanUseNow > 0) {
	            storeSystem.storeNow = storeSystem.storeNow + storeAndCanUseNow;
	        }
	        if (unitSupply > 0) {
	            storeSystem.store(unitSupply);
	        }
	    }
	}

