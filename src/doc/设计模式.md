https://zhuanlan.zhihu.com/p/114244039

1. 工厂模式
   实例化对象不是用new，用工厂方法替代。将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。
   https://juejin.cn/post/6992716383893061663
    spring中核心组件，BeanFactory，内部有很多重载的getBean方法，来创建各种不同类型，单例，原型的，最后通过getBean获取对象。
1*. 工厂方法：FactoryBean

2. 单例模式
   Spring 依赖注入 Bean实例默认是单例的

3. 装饰器模式：动态的将新功能附加到对象上。在对象功能的拓展方面，比继承更有弹性。
   https://blog.csdn.net/qq_44750696/article/details/123542907
   Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。
   使用：
   - 注册时发送注册成功邮件
   - MyBatis缓存机制，BaseExecutor中存放一级缓存，如果开启二级缓存时，会对一级缓存进行包装，比如加上LruCache（缓存清除）
   - Redis加缓存
    
  * java中的注解
    ·public @interface AnnotaionName{
        public 属性类型 属性名() default 默认值； // 不强制要求有default
    }·
  * 使用：
  - 生成文档， @Documented， 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档
  - pojo类中字段校验，用自定义注解实现
  - junit 框架，使用 @Test注解
  - 在反射中使用，（注解的生命周期，默认生命周期是class，需要runtime才会被反射获取到）

## 装饰器模式 vs 代理模式
   - 装饰器模式： 装饰者和被装饰者都实现同一个接口；强调增强自身功能
   - 代理模式：为了实现对象的控制
 
4. 代理模式
   在不修改目标对象的功能前提下,对目标功能扩展，减少代码侵入
   * 静态代理
     涉及变动，需要同时修改目标对象和代理对象
   * 动态代理
     将目标对象传入代理类，实现动态代理。然后通过反射，给目标对象生成代理对象
   * 应用
   - AOP底层，就是动态代理模式的实现：日志，事务，权限，检测 https://blog.csdn.net/Cr1556648487/article/details/126777903
   - 使用代理动态切换数据源 
5. 观察者模式
   对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。这种模式有时又称作发布-订阅模式
   使用：
   - spring的监听模式，在implement OnApplicationEventReay事件，在容器就绪后，初始化环境信息（租户信息）
   - 消息队列

6. 责任链模式
责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

责任链模式是一种对象行为型模式，其主要优点如下。

降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。




### [适配器模式](https://blog.51cto.com/u_15061944/4562911)：

```java
public class Bean {
    // 本身能力是画方形，需要画圆
    interface Adaptee {
        void drawTriangle();
    }

    interface Target{
        void drawCircle();
    }
    
    class Triangle implements Adaptee {
        @Override
        public void drawTriangle() {
            System.out.println("This is a Triangle!");
        }
    }

    abstract class Adapter implements Target {
        Adaptee adaptee;

        public Adapter(Adaptee adaptee) {
            this.adaptee = adaptee;
        }
    }

    class chinaMakeAdapter extends Adapter {
        public chinaMakeAdapter(Adaptee adaptee) {
            super(adaptee);
        }

        @Override
        public void drawCircle() {
            adaptee.drawTriangle();
            System.out.println("transfer triangle to circle!");
        }
    }

    public void main(String[] args) {
        Adaptee adaptee = new Triangle();
        Adapter adapter = new chinaMakeAdapter(adaptee);
        adapter.drawCircle();
    }
}
```

### [观察者模式](https://juejin.cn/post/6844904100459446285) :
当client 调用 subject的时候，就会通知 observer （调用observer中的方法）
1. 被观察者中添加观察者list
2. 当被观察者中事件发生时，通知list中所有观察者
3. 观察者接接收到被调用的信息后，可以做出相应的业务操作


spring中的事件驱动模型
1. 事件：ApplicationEvent，就是被观察者 | 如果新建自定义事件需要继承它
2. 事件监听器：ApplicationListener，就是观察者，继承 EventListener，该接口中有onApplicationEvent函数 | 当监听事件发生时，会调用这个方法
3. 事件源：ApplicationListener，是spring的核心容器，负责发布**事件**
4. 事件管理：ApplicationEventMulticaster，用于Listener的注册和事件的广播


自定义ruleEngineListener implement ApplicationListener<ApplicationReadyEvent> {
// 重写onApplicationEvent函数，实现初始化数据操作
}

相当于监听，readyEvent，然后触发操作

### [责任链模式](https://www.cnblogs.com/xrq730/p/10633761.html)

https://blog.csdn.net/CS_COPy/article/details/122867913
