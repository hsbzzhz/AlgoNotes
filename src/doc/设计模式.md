[spring中的9种设计模式](https://zhuanlan.zhihu.com/p/114244039)

### [Adapter 适配器模式](https://blog.51cto.com/u_15061944/4562911)：

```java
public class Bean {
    // 本身能力是画方形，需要画圆
    interface Adaptee {
        void drawTriangle();
    }

    interface Target{
        void drawCircle();
    }
    
    class Triangle implements Adaptee {
        @Override
        public void drawTriangle() {
            System.out.println("This is a Triangle!");
        }
    }

    abstract class Adapter implements Target {
        Adaptee adaptee;

        public Adapter(Adaptee adaptee) {
            this.adaptee = adaptee;
        }
    }

    class chinaMakeAdapter extends Adapter {
        public chinaMakeAdapter(Adaptee adaptee) {
            super(adaptee);
        }

        @Override
        public void drawCircle() {
            adaptee.drawTriangle();
            System.out.println("transfer triangle to circle!");
        }
    }

    public void main(String[] args) {
        Adaptee adaptee = new Triangle();
        Adapter adapter = new chinaMakeAdapter(adaptee);
        adapter.drawCircle();
    }
}
```

### [观察者模式](https://juejin.cn/post/6844904100459446285) :
- 观察模式流程:
1. 被观察者中添加观察者list
2. 当client调用**被观察者**，或某特定业务发生时，通知list中所有观察者
3. 观察者接接收到被调用的信息后，可以做出相应的业务操作


- spring中的事件驱动模型:
1. 事件：ApplicationEvent，就是被观察者 | 如果新建自定义事件需要继承它
2. 事件监听器：ApplicationListener，就是观察者，继承 EventListener，该接口中有onApplicationEvent函数 | 当监听事件发生时，会调用这个方法
3. 事件源：ApplicationListener，是spring的核心容器，负责发布**事件**
4. 事件管理：ApplicationEventMulticaster，用于Listener的注册和事件的广播

### 使用场景:
- 在容器就绪后，初始化环境信息（租户信息
```java
public void ruleEngineListener implement ApplicationListener<ApplicationReadyEvent> {
    // 重写onApplicationEvent函数，实现初始化数据操作
    // 相当于监听，readyEvent，然后触发操作
}
```
- 消息队列

### [责任链模式](https://www.cnblogs.com/xrq730/p/10633761.html)


### 工厂模式
   实例化对象不是用new，用工厂方法替代。将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。
   https://juejin.cn/post/6992716383893061663
    spring中核心组件，BeanFactory，内部有很多重载的getBean方法，来创建各种不同类型，单例，原型的，最后通过getBean获取对象。
- 工厂方法：FactoryBean

### 单例模式
   Spring 依赖注入 Bean实例默认是单例的

### [装饰器模式](https://blog.csdn.net/qq_44750696/article/details/123542907)
动态的将新功能附加到对象上。在对象功能的拓展方面，比继承更有弹性。
   
   Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。
   使用：
   - 注册时发送注册成功邮件
   - MyBatis缓存机制，BaseExecutor中存放一级缓存，如果开启二级缓存时，会对一级缓存进行包装，比如加上LruCache（缓存清除）
   - Redis加缓存
    
  * java中的注解
```java
    public @interface AnnotaionName{
        public 属性类型 属性名() default 默认值； // 不强制要求有default
    }
```
    
  * 使用：
  - 生成文档， @Documented， 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档
  - pojo类中字段校验，用自定义注解实现
  - junit 框架，使用 @Test注解
  - 在反射中使用，（注解的生命周期，默认生命周期是class，需要runtime才会被反射获取到）

## 装饰器模式 vs 代理模式
   - 装饰器模式： 装饰者和被装饰者都实现同一个接口；强调增强自身功能
   - 代理模式：为了实现对象的控制
 
### 代理模式
   在不修改目标对象的功能前提下,对目标功能扩展，减少代码侵入
   * 静态代理
     涉及变动，需要同时修改目标对象和代理对象
   * 动态代理
     将目标对象传入代理类，实现动态代理。然后通过反射，给目标对象生成代理对象
   * 应用
   - AOP底层，就是动态代理模式的实现：日志，事务，权限，检测 https://blog.csdn.net/Cr1556648487/article/details/126777903
   - 使用代理动态切换数据源
