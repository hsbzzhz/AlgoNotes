
redis数据类型 https://blog.csdn.net/qq_45076180/article/details/109458668

tcc[https://blog.csdn.net/sinat_32873711/article/details/129848895]

xa[https://juejin.cn/post/7116916308825866254]

可靠消息最终一致性方案[https://blog.csdn.net/Pastxu/article/details/115731491?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-115731491-blog-130501345.235^v43^pc_blog_bottom_relevance_base4&spm=1001.2101.3001.4242.2&utm_relevant_index=4]

RocketMQ半消息（2PC）
[https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&mid=2650860292&idx=3&sn=21be1aef473c4ceb1f2b00116fd4f671&chksm=bd017e4a8a76f75c89aea1b820f6e76071406c9e3cdd7c61cad99c92d6a59baff1daaf751d38&scene=27]
[https://blog.csdn.net/weixin_44606481/article/details/129903032]
1. A系统在执行本地事务前发送一个prepared消息到mq（prepared的topic是不可见的），如果这个prepared消息发送失败久取消后续操作
2. 如果这个消息发送成功，就继续执行本地事务，如果成功通知mq发送确认信息，如果失败就本地回滚并通知mq删除prepared消息
3. A系统发送了确认消息后，B系统会通过Topic收到确认消息，然后开始执行本地事务
4. 期间mq会定时论文所有prepared消息回调服务接口，查询本地事务处理结果。此步骤目的是避免本地事务执行成功，但确认消息缺发送失败
   1. 需要设计一张Transaction表，和业务表绑定，方便RocketMQ回查
5. 如果B系统中本地事务执行失败，首先会尝试重试，如遇失败需要通知A系统回滚（这里具体操作）
   1. RocketMQ不能保障消息重复，所以在消费端需要做幂等处理


[java场景加密算法]
对称加密 - AES
它使用相同的密钥进行加密和解密，用于网络通信和数据存储

非对称加密 - RSA
使用一对密钥，公钥用于加密，私钥用于解密。 在数字签名种，用私钥加密，公钥解密

散列函数 - SHA256、MD5
将输入数据转换为256位的哈希值，是不可逆的。用于验证数据完整，密码存储

数字签名 - DSA
它运行用私钥签署消息，以便使用公钥验证签名的有效性，以确保数据的来源和完整性

[java IO]
https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&amp;mid=2247491115&amp;idx=1&amp;sn=14f1712cc787befd6c78d64612a00f95&amp;chksm=c28571eaf5f2f8fca45ea7caf3ae7b5dee57c89e2cf7c0d115d0fa5211cca976e3462ea5cb74&amp;token=950876690&amp;lang=zh_CN&amp;scene=21#wechat_redirect



[黏包与拆包]https://blog.csdn.net/a724888/article/details/126912461
为什么用netty替代原生java nio
1. java nio 的ByteBuffer 构造函数私有，无法扩展。
2. Epoll方法缺陷，会导致无效状态的选择和100%的CPU利用率

拆包：
当一次发送Socket数量过大，TCP/IP不支持一次发送那么大的数据，就会发送拆包现象
黏包：
当短时间内发送（socket）很多数据量很小的包，就会把一些包合并成一个包发送

TCP种可能出现黏包/拆包的原因：
数据流在TCP协议下传播，因为协议本身对于流有一些规则限制，这些规则导致当前 端接受到的数据包不完整：
1. Socket缓冲区与滑动窗口
2. MSS/MTU限制（MSS是在MTU基础上减去网络层IP Header和传输曾的TCP Header部分，也就是TCP协议可以发送实际应用数据的最大大小）
3. Nagle算法*：

综上
出现粘包可能的原因有：
发送方每次写入数据 < 套接字缓冲区大小；
接收方读取套接字缓冲区数据不够及时。

出现半包的可能原因有：
发送方每次写入数据 > 套接字缓冲区大小；
发送的数据大于协议 MTU，所以必须要拆包。

解决方案：
1、在数据的末尾添加特殊的符号标识数据包的边界。通常会加\n、\r、\t或者其他的符号；
2、规定报文的长度，不足则补空位。读取时按规定好的长度来读取。比如 100 字节，如果不够就补空格；
3、将消息分为消息头和消息体，消息头中包含表示信息的总长度（或者消息体长度）的字段，按长度获取数据；
4、通过自定义协议进行粘包和拆包。

Netty黏包和拆包解决方案：
netty内置了如下解码器：
1. FixedLengthFrameDecoder（使用定长的报文来分包）
2. DelimiterBasedFrameDecoder（添加特殊分隔符报文来分包）
